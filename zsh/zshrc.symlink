#zmodload zsh/zprof         # NOTE: uncomment for profiling

export DOTFILES="$HOME/.dotfiles"
export DOTFILES_OS="$(${DOTFILES}/bin/get_os)"
export SH_PLUGIN="${DOTFILES}/sh-plugins/bin"
export GOPATH="${HOME}/gocode"
export PATH="${GOPATH}/bin:${DOTFILES}/bin:${PATH}"
[[ -d ${HOME}/.skim/bin ]] && export PATH="${HOME}/.skim/bin:${PATH}"

export EDITOR="nvim"
export SKIM_DEFAULT_COMMAND="fd ."

# {{{ config
export HISTFILE=~/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000

setopt APPEND_HISTORY           # adds history
# adds history incrementally and share it across sessions
setopt INC_APPEND_HISTORY SHARE_HISTORY
setopt EXTENDED_HISTORY         # add timestamps to history

# don't record dupes in history
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_REDUCE_BLANKS
# }}}
# {{{ aliases
alias b='bat'
alias g='git'
alias vc='e ~/.config/nvim/init.vim'
alias l='exa'
alias ll='exa -l'
# }}}

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit -d
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*' insert-tab pending
compdef g=git
compdef l=exa
compdef ll=exa

zstyle \
    'history' \
    'completion' \
    'git'

#{{{ Prompt
# The following are stolen and adapted from @agkozak's wonderful prompt:
# https://github.com/agkozak/agkozak-zsh-prompt, which got this functionality
# was specifically added by @psprint in
# https://github.com/agkozak/agkozak-zsh-prompt/pull/11
#
# This contains just the bare minimum in order to get everything working on my
# machine.

setopt promptsubst
# `man zshmisc`
PROMPT='%F{blue}%~%f %{$psvar[1]%}%F{yellow}$(_timeit)%f
%(?.%F{magenta}.%F{red})%(!.#.$)%f '

psvar=()
preexec() { psvar[3]=$(_now); }
precmd() {
    setopt LOCAL_OPTIONS NO_IGNORE_BRACES
    async_vcs_info
    psvar[2]=$(_time_it "${psvar[3]:-}")
    psvar[3]=
}

function _now() { date +%s; }
function _time_it() {
    [[ -z $1 ]] && return
    now=$(_now)
    diff=$(( now - $1 ))
    min=$(( diff / 60 ))
    sec=$(( diff % 60 ))
    if (( min > 60 )); then
        echo ">1h"
    elif (( min != 0 && sec != 0 )); then
        echo "${min}m ${sec}s"
    elif (( min != 0 )); then
        echo "${min}m"
    elif (( sec > 2 )); then
        echo "${sec}s"
    fi
}
typeset -g VCS_INFO_FD=${RANDOM}
function async_vcs_info() {
    [[ ! -f "$(command -v git-prompt)" ]] && return 0
    pkill git-prompt
    [[ ${PWD} != ${psvar[4]} ]] && psvar[1]=''
    psvar[4]="${PWD}"

    exec {VCS_INFO_FD}< <(
        git-prompt --print-updates || :   # ensure EOF is sent
        echo "EOF"
    )
    zle -F "$VCS_INFO_FD" async_vcs_info_callback
}
function async_vcs_info_callback() {
    setopt LOCAL_OPTIONS NO_IGNORE_BRACES

    case ${2:-} in        # process the error, see zshzle -F manpage
        nval) pkill git-prompt && return 0;;    # closed or invalid descrptor
        hup|err) pkill git-prompt && return 0;; # disconnect | any other error
    esac

    local FD="$1" response
    builtin read -u "$FD" response
    if [[ $response == "Err: "* || $response == "EOF" ]]; then
        exec {FD}<&- # close the file descriptor
        zle -F "${FD}" # Remove any handler associated with this descriptor
        return
    fi

    # Include a space, so that we don't do partial matching we don't want
    if [[ "${psvar[1]} " != "$response *" ]]; then
        psvar[1]="$response"
        zle && { zle reset-prompt; zle -R }
    fi
}

function _prompt_char() {
    if [[ $? -ne 0 ]]; then
        echo "%F{red}$%f"
        return
    fi
    echo "%F{magenta}$%f"
}
setopt promptsubst
# http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
PROMPT='%F{blue}%~%f %{$psvar[1]%}%F{yellow} %{$psvar[2]%}%f
$(_prompt_char) '
#}}}

trysource() { [ -f "${1}" ] && source "${1}"; }
trysource "${HOME}/.localrc"
trysource "${HOME}/.skim/shell/completion.zsh"
trysource "${HOME}/.skim/shell/key-bindings.zsh"

#{{{ Functions
[[ "${DOTFILES_OS}" == "ArchLinux" ]] && aur() {
case "$1" in
    "--help"|"-h")
        cat <<EOF
AUR downloading function.

Usage:
  aur [-s|--search] [PACKAGE_NAME]
EOF
return
;;
''|'-s'|'--search')
    local input
    if [[ -z $2 ]]; then
        echo -n "enter AUR search term: "
        read input
    else
        input="$2"
    fi
    selection=$(
    curl --silent "https://aur.archlinux.org/rpc/?v=5&type=search&arg=$input" |
        jq -r '.results[] | "\(.NumVotes)\t\(.Name)\t\(.Description)"' |
        awk '{pop=$1;name=$2; $1="";$2=""; printf "%5d \x1b[34;1m%s\x1b[m\t%s\n", pop, name, $0}' |
        sort -n -r |
        column -t -s $'\t' |
        sk --ansi |
        awk '{print $2}')
            aur "$selection"
            return
            ;;
        *)
            local dir="${HOME}/aur/$1"
            [[ ! -d "$dir" ]] && git clone "https://aur.archlinux.org/$1.git" "$dir"

            pushd "$dir"
            git checkout .
            git pull --rebase origin master
            ;;
    esac
}

rsw () {
    watchit \
        --include="Cargo\.toml" \
        --include="*\.rs" \
        cargo "$@"
}

rsd () {
    # Original idea based on: https://github.com/rust-lang/rfcs/issues/2324,
    # however it would be great to have a 'cargo doc' to include the stdlib docs
    # instead of linking to the online ones.
    readonly local docpath="$(dirname "$(rustup doc --path)")/"
    echo "Syncing $docpath to ./target/doc..."
    rsync -r "$docpath" ./target/doc/
    echo "Done"
    rsw doc --all --document-private-items "$@"
}

bw() {
    watchit \
        --include="BUILD\.bazel" \
        --include="*\.go" \
        bazel "$@"
}

shed() {
    docker run --name shed -v ${PWD}:/x -w /x -ti --rm aignas/shed "$@"
}
#}}}

# vim: fdm=marker
