#!/usr/bin/env zsh
# NOTE: uncomment for profiling
#zmodload zsh/zprof

export DOTFILES="$HOME/.dotfiles"
export DOTFILES_OS="$(${DOTFILES}/bin/get_os)"
export SH_PLUGIN="${DOTFILES}/sh-plugins/bin"
export GOPATH="${HOME}/gocode"
export PATH="${GOPATH}/bin:${DOTFILES}/bin:${PATH}"
[[ -d ${HOME}/.skim/bin ]] && export PATH="${HOME}/.skim/bin:${PATH}"

export EDITOR="nvim"
export SKIM_DEFAULT_COMMAND="fd ."

# {{{ config
export HISTFILE=~/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000

setopt APPEND_HISTORY           # adds history
# adds history incrementally and share it across sessions
setopt INC_APPEND_HISTORY SHARE_HISTORY
setopt EXTENDED_HISTORY         # add timestamps to history

# don't record dupes in history
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_REDUCE_BLANKS
# }}}
# {{{ aliases
alias b='bat'
alias g='git'
alias vc='e ~/.config/nvim/init.vim'
alias l='exa'
alias ll='exa -l'
# }}}

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit -d
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*' insert-tab pending
compdef g=git
compdef l=exa
compdef ll=exa

zstyle \
  'history' \
  'completion' \
  'git'

#{{{ Prompt
_git_prompt() { "${SH_PLUGIN}/git_prompt" "$@"; }

# The following are stolen adaptet form @agkozak's wonderful prompt:
# https://github.com/agkozak/agkozak-zsh-prompt, which got this functionality
# was specifically added by @psprint in
# https://github.com/agkozak/agkozak-zsh-prompt/pull/11
#
# This contains just the bare minimum in order to get everything working on my
# machine.

setopt promptsubst
# `man zshmisc`
PROMPT='%F{blue}%~%f %{$psvar[1]%}%F{yellow}$(_timeit)%f
%(?.%F{magenta}.%F{red})%(!.#.$)%f '

psvar=()
preexec() { psvar[2]=$(_now); }
_timeit() {
  last=${psvar[2]:-}
  psvar[2]=

  [[ -z $last ]] && return
  diff=$(( $(_now) - last ))
  (( diff < 3 )) && return

  min=$(( diff / 60 ))
  sec=$(( diff % 60 ))
  if (( min > 60 )); then
    echo ">1h"
  elif (( sec == 0 )); then
    echo "${min}m"
  elif (( min == 0 )); then
    echo "${sec}s"
  else
    echo "${min}m ${sec}s"
  fi
}
_now() { date +%s; }

precmd() {
  if [[ ${PWD} != ${psvar[6]} ]]; then
    psvar[4]=''
    psvar[5]=''
    psvar[1]=''
  fi
  psvar[6]="${PWD}"

  typeset -g VCS_INFO_FD=${RANDOM}
  exec {VCS_INFO_FD}< <(_git_prompt --no-status)
  zle -F "$VCS_INFO_FD" async_vcs_branch_callback
}
async_vcs_branch_callback() {
  setopt LOCAL_OPTIONS NO_IGNORE_BRACES

  local FD="$1" response extra
  IFS='' builtin read -rs -d $'\0' -u "$FD" response
  zle -F "${FD}"; exec {FD}<&- # Withdraw callback and close the file descriptor

  [[ $response == ' ' ]] && response=''
  if [[ "${psvar[4]}" != "$response" ]]; then
    psvar[4]="$response"
    psvar[5]=''
    psvar[1]="$response"
    zle && { zle reset-prompt; zle -R }
  fi
  [[ "$response" == '' ]] && return

  typeset -g VCS_INFO_FD=${RANDOM}
  exec {VCS_INFO_FD}< <(_git_prompt --no-branch --no-diff)
  zle -F "$VCS_INFO_FD" async_vcs_status_callback
}
async_vcs_status_callback() {
  setopt LOCAL_OPTIONS NO_IGNORE_BRACES

  local FD="$1" response extra
  IFS='' builtin read -rs -d $'\0' -u "$FD" response
  zle -F "${FD}"; exec {FD}<&- # Withdraw callback and close the file descriptor

  [[ $response == ' ' ]] && response=''
  if [[ "${psvar[5]}" != "$response" ]]; then
    psvar[5]="$response"
    psvar[1]="${psvar[4]}${psvar[5]}"
    zle && { zle reset-prompt; zle -R }
  fi
}
#}}}

trysource() { [ -f "${1}" ] && source "${1}"; }
trysource "${HOME}/.localrc"
trysource "${HOME}/.skim/shell/completion.zsh"
trysource "${HOME}/.skim/shell/key-bindings.zsh"

#{{{ Functions
[[ "${DOTFILES_OS}" == "ArchLinux" ]] && aur() {
  case "$1" in
    "--help"|"-h")
      cat <<EOF
AUR downloading function.

Usage:
  aur [-s|--search] [PACKAGE_NAME]
EOF
      return
      ;;
    ''|'-s'|'--search')
      local input
      if [[ -z $2 ]]; then
        echo -n "enter AUR search term: "
        read input
      else
        input="$2"
      fi
      selection=$(
        curl --silent "https://aur.archlinux.org/rpc/?v=5&type=search&arg=$input" |
          jq -r '.results[] | "\(.NumVotes)\t\(.Name)\t\(.Description)"' |
          awk '{pop=$1;name=$2; $1="";$2=""; printf "%5d \x1b[34;1m%s\x1b[m\t%s\n", pop, name, $0}' |
          sort -n -r |
          column -t -s $'\t' |
          sk --ansi |
          awk '{print $2}')
      aur "$selection"
      return
      ;;
    *)
      local dir="${HOME}/aur/$1"
      [[ ! -d "$dir" ]] && git clone "https://aur.archlinux.org/$1.git" "$dir"

      pushd "$dir"
      git checkout .
      git pull --rebase origin master
      ;;
  esac
}

rsw () {
  echo "Running local CI [ hit CTRL+C to stop ]"
  {
    fd Cargo
    fd -e rs
  } | entr -d cargo "$@"
}

rsd () {
  # Original idea based on: https://github.com/rust-lang/rfcs/issues/2324,
  # however it would be great to have a 'cargo doc' to include the stdlib docs
  # instead of linking to the online ones.
  readonly local docpath="$(dirname "$(rustup doc --path)")/"
  echo "Syncing $docpath to ./target/doc..."
  rsync -r "$docpath" ./target/doc/
  echo "Done"
  rsw doc --all --document-private-items "$@"
}
#}}}

# vim: tw=80:ft=zsh:sw=2:ts=2:fdm=marker
