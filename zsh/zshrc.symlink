#
# My zshrc configuration. Use or reuse however you like.
#       by gns-ank

# shortcut to this dotfiles path is $ZSH
export DOTFILES="$HOME/.dotfiles"
export DOTFILES_OS="$(${DOTFILES}/bin/get_os)"
export SH_PLUGIN="${DOTFILES}/sh-plugins/bin"
export GOPATH="${HOME}/gocode"
export PATH="${GOPATH}/bin:${DOTFILES}/bin:${PATH}"
[[ -d ${HOME}/.skim/bin ]] && export PATH="${HOME}/.skim/bin:${PATH}"

export EDITOR="nvim"
export SKIM_DEFAULT_COMMAND="fd ."

# {{{ config
export HISTFILE=~/.zsh_history
export HISTSIZE=10000
export SAVEHIST=10000

setopt APPEND_HISTORY           # adds history
# adds history incrementally and share it across sessions
setopt INC_APPEND_HISTORY SHARE_HISTORY
setopt EXTENDED_HISTORY         # add timestamps to history

# don't record dupes in history
setopt HIST_IGNORE_ALL_DUPS
setopt HIST_REDUCE_BLANKS
# }}}
# {{{ aliases
alias b='bat --theme=zenburn'
alias g='git'
alias h='hub'
alias gf='git fetch --all'
alias k='kubectl'
alias se='sudo -E e'
alias vc='e ~/.config/nvim/init.vim'
alias x='exa'
alias xx='exa -l'
# }}}

# initialize autocomplete here, otherwise functions won't be loaded
autoload -U compinit
compinit
zstyle ':completion:*' matcher-list 'm:{a-z}={A-Z}'
zstyle ':completion:*' insert-tab pending
compdef g=git

zstyle \
  'history' \
  'completion' \
  'git'

trysource() {
  [ -f "${HOME}/${1}" ] && source "${HOME}/${1}"
}

plug() {
  exec "${SH_PLUGIN}/$1"
}

precmd() {
  # http://zsh.sourceforge.net/Doc/Release/Prompt-Expansion.html
  PS1="%F{blue}%~%f $(plug git_prompt)
%F{magenta}‚ùØ%f "
  export PS1
}

if [[ "${DOTFILES_OS}" == "ArchLinux" ]]
then
  aurd() {
    p="${HOME}/aur/$1"
    [[ ! -d "$p" ]] && git clone "https://aur.archlinux.org/$1.git" "$p"
    pushd "$p" && git pull --rebase origin master
  }
fi

rsw () {
  echo "Running local CI [ hit CTRL+C to stop ]"
  {
    fd Cargo
    fd -e rs
  } | entr -cd cargo "$@"
}

# trysource ${HOME}/.fzf.zsh
trysource .localrc
trysource .skim/shell/completion.zsh
trysource .skim/shell/key-bindings.zsh

# fco - checkout git branch/tag
fco() {
  local targets prefix
  case $1 in
    t|tag)
      prefix=tag
      targets=$(git tag || return)
      ;;
    ''|b|branch)
      prefix=branch
      targets=$(git branch --all |
        grep -v HEAD |
        sed "s/.* //" |
        sed "s#remotes/[^/]*/##" || return)
      ;;
    *)
      cat <<EOF
Interactive checkout a branch or a tag.

Subcommands:
 [|b|branch]: branch checkout
 [t|tag]: tag checkout
EOF
      return
      ;;
  esac
  [[ -z ${targets} ]] && return
  target=$(echo "$targets" |
    sort -u |
    awk -v prefix="$prefix" '{print "\x1b[31;1m" prefix "\x1b[m\t" $1}' |
    sk --no-hscroll --ansi -d "\t" -n 2) || return
  git checkout "$(echo "$target" | awk '{print $2}')"
}

c() {
  while true
  do
    target=$(
      fd --type=d -H --follow --max-depth 1 "$@" |
        sort -u |
        sk --ansi) || return
    cd "$target" || return
  done
}

# Run the search with multiple fd instances in parallel
crget() {
  for dir in "${@:-${HOME}/src}"
  do
    fd --hidden --type=d --max-depth 5 "^\.git$" "$dir" -x dirname {}\; &
  done
  wait
}

cr() {
  target=$(crget "$@" |
      sort -u |
      awk '{print "\x1b[31;1mrepo\x1b[m\t" $1}' |
      sk --no-hscroll --ansi -d "\t" -n 2) || return
  cd "$(echo "$target" | awk '{print $2}')" || return
}

st() {
  local target="$1"
  if [[ -z $target ]]
  then
    target=$(fd --type=d --follow --max-depth 3 . |
      sort -u |
      sk --ansi) || return
  elif [[ ! -d $target ]]
  then
    echo "Please provide a path that is a directory and exists"
    return 1
  fi
  sh -c "scantest -command 'go test -covermode=count -coverprofile=./$target/coverage.out ./$target/...'"
}

ct() {
  case $1 in
    rm)
      echo "cleaning coverage files up"
      fd --type=f -I coverage.out -x rm {}
      ;;
    '')
      file=$(fd --type=f -I coverage.out |
        sort -u |
        sk --ansi) || return
      go tool cover -html="$file"
      ;;
    *)
      cat <<EOF
Search for coverage files and open them in a browser window using 'go tool
cover'.

Subcommands:
  rm: cleanup all coverage files
EOF
      ;;
  esac
}

# vim: tw=80:ft=zsh:sw=2:ts=2:fdm=marker
