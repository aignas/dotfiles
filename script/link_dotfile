#!/bin/bash

[[ -z "${DOTFILES_ROOT}" ]] && DOTFILES_ROOT="$(cd "$(dirname "$0")/.." && pwd)"

# shellcheck source=/dev/null
source "${DOTFILES_ROOT}/script/logging.sh"

print_help() {
    cat <<EOF
link_dotfile -- dotfiles management

Usage: link_dotfile [options]

Options:
  -o, --overwrite Replace the existing dotfiles with dotfile symlinks
  -b, --backup    Backup the existing dotfiles before creating dotfile symlinks
  -s, --skip      Skip the existing dotfiles
  -h, --help      Show this help message and exit
EOF
}

OVERWRITE=''
BACKUP=''
SKIP=''

while test $# -gt 1; do
    case "$1" in
    "-h" | "--help")
        print_help
        exit
        ;;
    "-o" | "--overwrite") OVERWRITE=true ;;
    "-b" | "--backup") BACKUP=true ;;
    "-s" | "--skip") SKIP=true ;;
    *)
        fail "Invalid option: $1"
        print_help
        exit
        ;;
    esac
    shift
done

# realpath is a cross-platform way of getting the realpath. It is available on
# Linuxes, but not MacOS and this version works on `/bin/sh` as per author's
# claim.
# Taken from https://stackoverflow.com/a/18443300
realpath() {
  local OURPWD=$PWD
  cd "$(dirname "$1")"
  local LINK=$(readlink "$(basename "$1")")
  while [ "$LINK" ]; do
    cd "$(dirname "$LINK")"
    local LINK=$(readlink "$(basename "$1")")
  done
  local REALPATH="$PWD/$(basename "$1")"
  cd "$OURPWD"
  echo "$REALPATH"
}

src="$(realpath "$1")"

# Check if we have a destination config file, which tells us where the
# symlink will endup:
postfix="$HOME/."
if echo "${src}" | grep -E -q "\.xdg$"; then
    postfix="${XDG_CONFIG_HOME:-${HOME}/.config}/"
    mkdir -p "$postfix"
fi

dst="$postfix$(basename "${src%.*}")"

status=
if [[ -f "$dst" || -d "$dst" || -L "$dst" ]]; then
    if [ "$OVERWRITE" == "true" ]; then
        rm -rf "$dst"
        status="replace"
    fi

    if [ "$BACKUP" == "true" ]; then
        mv "$dst" "${dst}.bak"
        status="backup "
    fi

    if [[ -f "$dst" || -d "$dst" || -L "$dst" ]]; then
        status="skip  "
        SKIP=true
    fi
fi

if [[ "$SKIP" != "true" ]]; then
    if [[ -r "$DOTFILES_ROOT/$src" ]]; then
        src="${DOTFILES_ROOT}/$src"
    fi
    ln -s "$src" "$dst"
    [[ -z $status ]] && status="create "
fi

ok "$status $dst"
